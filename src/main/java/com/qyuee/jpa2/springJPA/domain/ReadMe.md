### 엔티티 설계시 주의사항

- getter는 열어두고, setter는 가급적 필요한 경우에만 허용하도록 한다.
    - 엔티티를 변경하는 경우에는 `변경용 별도의 비즈니스 메소드`를 제공하는게 더 나은 방향이다.


- 외래키가 있는 곳을 연관관계의 주인으로 정하자.
    - 연관관계의 주인은 외래키를 단순히 `누가!` 관리하냐에 따라서 정해야 한다.
    - 비지니스상 우위에 있는 쪽을 무조건 주인으로 설정하는 것은 옳지 않다.


- @ManyToMany의 경우에는 실무에서 사용하지 않도록 하자.
    - 중간 테이블에 해당하는 `중간 엔티티`를 별도로 생성하자. 그리고 다대일, 일대다 관계를 통해서 풀어내자.


- 값 타입(Address)의 경우에는 변경이 불가능하도록 설계해야한다.
    - @Setter를 모두 닫고, 최초에 값을 세팅 할 수 있는 `생성자`를 제공하자.
    - **(주의)** JPA 스펙상 엔티티나 임베디드 타입의 경우 `기본생성자`가 있어야한다. (JPA 구현라이브러리가 객체를 생성 할 때, 리플렉션 같은 기술을 사용 할 수 있도록 지원해야 함)


- 모든 연관관계는 `지연로딩`으로 설정하자.
    - 즉시로딩은 예측이 어렵고, 어떤 SQL이 실행되는지 추적하기 힘들다. 또한, JPQL을 사용 할 때, N+1 문제가 자주 발생한다.  
      단, N+1 이슈가 해결되는건 아니다. fetch join을 사용해야 N+1 문제를 `대부분` 해결 할 수 있다.
    - 연관된 엔티티를 함께 DB에서 조회하겠다면, fetch join이나 엔티티 그래프 기능을 사용한다.
    - @XToOne(OneToOne, ManyToOne) 관계는 기본적으로 즉시로딩이므로 `지연로딩`으로 설정해야 한다.


- 컬렉션은 필드에서 `초기화`하자
    - NPE에 대해서 안전하다.


- 테이블, 컬럼명 생성 전략
  - 스프링 부트 신규 설정 (엔티티 -> 테이블)
    - 카멜케이스 -> 언더스코어로 변경
    - .(점) -> _(언더스코어)
    - 대문자 -> 소문자